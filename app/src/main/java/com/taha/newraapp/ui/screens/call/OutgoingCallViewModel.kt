package com.taha.newraapp.ui.screens.call

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taha.newraapp.data.socket.CallSocketService
import com.taha.newraapp.domain.repository.CallRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel for managing outgoing call state.
 * Handles call initiation, socket events, and call UI visibility.
 */
class OutgoingCallViewModel(
    private val callRepository: CallRepository,
    private val callSocketService: CallSocketService
) : ViewModel() {
    
    companion object {
        private const val TAG = "OutgoingCallVM"
    }
    
    // Call state
    private val _callStatus = MutableStateFlow("Connecting...")
    val callStatus: StateFlow<String> = _callStatus.asStateFlow()
    
    private val _isCallActive = MutableStateFlow(false)
    val isCallActive: StateFlow<Boolean> = _isCallActive.asStateFlow()
    
    private val _callEnded = MutableStateFlow(false)
    val callEnded: StateFlow<Boolean> = _callEnded.asStateFlow()
    
    private val _isMuted = MutableStateFlow(false)
    val isMuted: StateFlow<Boolean> = _isMuted.asStateFlow()
    
    private val _isSpeakerOn = MutableStateFlow(false)
    val isSpeakerOn: StateFlow<Boolean> = _isSpeakerOn.asStateFlow()
    
    // Controls whether to show call UI (when callee accepts)
    private val _showJitsiUI = MutableStateFlow(false)
    val showJitsiUI: StateFlow<Boolean> = _showJitsiUI.asStateFlow()
    
    // LiveKit token for caller (received from API)
    private val _callerToken = MutableStateFlow<String?>(null)
    val callerToken: StateFlow<String?> = _callerToken.asStateFlow()
    
    // Current call info
    var currentCallId: String? = null
        private set
    private var currentRoomId: String? = null
    
    init {
        subscribeToCallEvents()
    }
    
    /**
     * Subscribe to call socket events (accepted/rejected/ended).
     */
    private fun subscribeToCallEvents() {
        // Listen for call accepted
        viewModelScope.launch {
            callSocketService.callAccepted.collect { event ->
                if (event.callId == currentCallId) {
                    Log.d(TAG, "Call accepted by ${event.acceptedBy}")
                    onCallAccepted()
                }
            }
        }
        
        // Listen for call rejected
        viewModelScope.launch {
            callSocketService.callRejected.collect { event ->
                if (event.callId == currentCallId) {
                    Log.d(TAG, "Call rejected by ${event.rejectedBy}: ${event.reason}")
                    onCallDeclined(event.reason ?: "declined")
                }
            }
        }
        
        // Listen for call ended
        viewModelScope.launch {
            callSocketService.callEnded.collect { event ->
                if (event.callId == currentCallId) {
                    Log.d(TAG, "Call ended by ${event.endedBy}: ${event.reason}")
                    _callStatus.value = "Call ended"
                    _callEnded.value = true
                }
            }
        }
    }
    
    /**
     * Initiate a call to the specified user.
     * Room ID is generated by the Activity and used for LiveKit connection.
     * This sends the API request to notify the callee.
     */
    fun initiateCall(
        calleeId: String,
        calleeName: String,
        isVideoCall: Boolean,
        roomId: String
    ) {
        currentRoomId = roomId
        
        viewModelScope.launch {
            try {
                Log.d(TAG, "Initiating call to $calleeId, room: $roomId, video: $isVideoCall")
                
                _callStatus.value = "Calling..."
                
                // Send initiate call request to backend (triggers FCM to callee)
                val callType = if (isVideoCall) "video" else "audio"
                val result = callRepository.initiateCall(
                    calleeId = calleeId,
                    roomId = roomId,
                    callType = callType
                )
                
                result.onSuccess { response ->
                    if (response.success) {
                        currentCallId = response.callId
                        _callerToken.value = response.token
                        _callStatus.value = "Ringing..."
                        _isCallActive.value = true
                        Log.d(TAG, "Call initiated successfully: ${response.callId}, token received: ${response.token != null}")
                    } else {
                        // Server returned success=false
                        Log.e(TAG, "Server rejected call: ${response.error}")
                        _callStatus.value = response.error ?: "Call failed"
                        // Send end call to stop callee's phone from ringing
                        callSocketService.endCall(response.callId, "error")
                        kotlinx.coroutines.delay(2000)
                        _callEnded.value = true
                    }
                    
                }.onFailure { error ->
                    Log.e(TAG, "Failed to initiate call", error)
                    _callStatus.value = "Call failed"
                    // Send end call if we have a callId
                    currentCallId?.let { callSocketService.endCall(it, "error") }
                    kotlinx.coroutines.delay(2000)
                    _callEnded.value = true
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Exception during call initiation", e)
                _callStatus.value = "Call failed"
                // Send end call if we have a callId
                currentCallId?.let { callSocketService.endCall(it, "error") }
                kotlinx.coroutines.delay(2000)
                _callEnded.value = true
            }
        }
    }
    
    /**
     * Called when callee accepts the call.
     * Hides our custom overlay to show the call UI.
     */
    private fun onCallAccepted() {
        Log.d(TAG, "Call accepted - showing call UI")
        _callStatus.value = "Connected"
        _showJitsiUI.value = true
    }
    
    /**
     * Called when callee declines the call.
     */
    private fun onCallDeclined(reason: String = "declined") {
        Log.d(TAG, "Call declined: $reason")
        _callStatus.value = when (reason) {
            "busy" -> "User is busy"
            "timeout" -> "No answer"
            else -> "Call declined"
        }
        
        viewModelScope.launch {
            kotlinx.coroutines.delay(2000)
            _callEnded.value = true
        }
    }
    
    /**
     * End the current call.
     */
    fun endCall() {
        Log.d(TAG, "Ending call")
        _callStatus.value = "Call ended"
        _isCallActive.value = false
        
        // Send end call request via socket
        currentCallId?.let { callId ->
            callSocketService.endCall(callId, "hangup")
        }
        
        _callEnded.value = true
    }
    
    /**
     * Toggle mute state.
     */
    fun toggleMute() {
        _isMuted.value = !_isMuted.value
        // TODO: Control call audio mute via LiveKit
    }
    
    /**
     * Toggle speaker state.
     */
    fun toggleSpeaker() {
        _isSpeakerOn.value = !_isSpeakerOn.value
        // TODO: Control speaker via AudioManager
    }
}
